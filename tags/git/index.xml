<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>rushiagr</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://www.rushiagr.com/tags/git/</link>
    <language>en-us</language>
    <author>Rushi Agrawal</author>
    <copyright>2016 Rushi Agrawal</copyright>
    <updated>Tue, 11 Oct 2016 17:59:46 IST</updated>
    
    
    <item>
      <title>Python Engineer Beginner Mistakes</title>
      <link>http://www.rushiagr.com/blog/2016/10/11/python-engineer-beginner-mistakes/</link>
      <pubDate>Tue, 11 Oct 2016 17:59:46 IST</pubDate>
      <author>Rushi Agrawal</author>
      <guid>http://www.rushiagr.com/blog/2016/10/11/python-engineer-beginner-mistakes/</guid>
      <description>

&lt;p&gt;I am writing Python code since 5 years, and I have worked with around 5-6
entry-level Python programmers. There is a pattern I can see in the programming
practices of such programmers, so I am listing the problems and their solutions
in this article. I have worked with OpenStack for over three years, which has a
very high code quality, so I feel I am qualified enough for writing this post.
My hope is this will be helpful for more entry-level Python programmers.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll start with talking about these beginner-programmers first. The people I
have worked with are not only self-taught Python programmers, but who also
worked in startups in Bangalore. For self-taught Python programmers, it is
understandable &amp;ndash; Python is a pretty easy language to pick up and code, so
there is really no motivation for them to go with best practices right from the
start, especially when all they can find is a huge list of good programming
practices and PEP8 conventions to follow. For Python beginners working in
startups, I am guessing there are not enough senior Python programmers who can
teach them about required best practices.&lt;/p&gt;

&lt;p&gt;In this article I&amp;rsquo;m going to list the bare-minimum of these simple practices
you should follow. Surprisingly, most of the &amp;lsquo;Beginner Python mistakes to
avoid&amp;rsquo; articles on the web don&amp;rsquo;t talk about the bad practices I encounter. I
think they just assume such simple things are taken care of by a programmer,
my experience tells otherwise.&lt;/p&gt;

&lt;p&gt;Note that this is just the beginning. There&amp;rsquo;s a TON of things you should worry
about, but you&amp;rsquo;ll learn them as you grow. Don&amp;rsquo;t worry :)&lt;/p&gt;

&lt;h2 id=&#34;indentation-tabs-and-spaces:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Indentation, tabs and spaces.&lt;/h2&gt;

&lt;p&gt;Never use tabs. Only use spaces. Use 4 spaces for a tab, always.&lt;/p&gt;

&lt;p&gt;I frequently see codes which use a mix of spaces and tabs, and 2-space and
4-space indentations all in one file!  If you are coming from a different
language, or if you already have a notion of, say, 8 spaces for a tab, then it
might be difficult and seem unnecessary at first. But I am guessing you are
liking the language and you look forward to writing lots and lots of Python
code in your lifespan; in such a case, just bear with me for a few weeks and
it&amp;rsquo;ll come naturally to you, trust me :)&lt;/p&gt;

&lt;h2 id=&#34;raise-specific-exceptions:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Raise specific exceptions&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t write like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try:
    # do something here
except Exception as e:
    # handle exception
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Catching the parent &lt;code&gt;Exception&lt;/code&gt; is bad. If you know what exception the code is
going to throw, just except that exception. The most common example I have seen
is when calling &lt;code&gt;get()&lt;/code&gt; method on a Django&amp;rsquo;s model. If the object is not
present, Django throws &lt;code&gt;ObjectDoesNotExists&lt;/code&gt; exception. Catch &lt;em&gt;this&lt;/em&gt; exception,
not Exception.&lt;/p&gt;

&lt;p&gt;Most often, you do some corrective action in the &amp;lsquo;handling exception&amp;rsquo; part. If
you are excepting (if there&amp;rsquo;s a word &amp;lsquo;excepting&amp;rsquo;) &lt;code&gt;Exception&lt;/code&gt;, then you are
heading straight into this &amp;lsquo;handling exception&amp;rsquo; section no matter what has
happened. Your database might be down but the &amp;lsquo;database down&amp;rsquo; exception might
still be caught and probably silently ignored of you do this.&lt;/p&gt;

&lt;h2 id=&#34;trailing-whitespaces:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Trailing whitespaces&lt;/h2&gt;

&lt;p&gt;In context of Python, whitespaces means space characters. There should be no
line in Python code which has spaces at it&amp;rsquo;s end.&lt;/p&gt;

&lt;p&gt;You might think why make such a big issue of this. The problem is
version/source control. You invariably will use a source control system at some
point of time, for example &amp;lsquo;git&amp;rsquo;. When you commit trailing spaces, it becomes
difficult to read the diffs (the difference between two commits/checkins).
Also, removing or adding more spaces might feel okay if you develop a habit of
leaving around trailing spaces. But when you will start using a source control
system, this will add unnecessary noise in commits, making code review and
debugging difficult. Remember, code is read much times than is written or
modified.&lt;/p&gt;

&lt;h2 id=&#34;edge-cases-first-shallow-nesting:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Edge cases first. Shallow nesting.&lt;/h2&gt;

&lt;p&gt;Consider two pseudo codes. These are codes for handling a request, but you can
altogether ignore that fact and it would still make sense:&lt;/p&gt;

&lt;p&gt;Pseudo code 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if request is post:
    if parameter &#39;param1&#39; is specified:
        if the user can be authenticated:
            if the user can perform this action:
                # Execute core business logic here
            else:
                return saying &#39;user cannot perform this action&#39;
    else:
        return saying &#39;parameter param1 is mandatory&#39;
else:
    return saying &#39;any other method apart from POST method is disallowed&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pseudo code 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if request is not post:
    return saying &#39;any other method apart from POST method is disallowed&#39;

if parameter &#39;param1&#39; is specified:
    return saying &#39;parameter param1 is mandatory&#39;

if the user can be authenticated:
    return saying &#39;user cannot be authenticated&#39;

if the user can perform this action:
    return saying &#39;user cannot perform this action&#39;

# Execute core business logic here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the second code is much easier to read. You will also notice
that the second code doesn&amp;rsquo;t have a lot of nesting, which avoids common
problems. Can you see that I have not written an &amp;lsquo;else&amp;rsquo; section? If the core
logic is several dozens of lines long, it becomes difficult to find out which
&lt;code&gt;else&lt;/code&gt; belongs to which &lt;code&gt;if&lt;/code&gt; if we write in &amp;lsquo;Pseudo code 1&amp;rsquo; style.&lt;/p&gt;

&lt;p&gt;I am sure while starting to write, pseudo code 1 should feel normal. But with
very minimal effort you can very soon get used to writing code in &amp;lsquo;pseudo code
2&amp;rsquo; style.&lt;/p&gt;

&lt;p&gt;The following are minor, probably opinionated suggestions. These might apply to
not only Python but any programming language. I feel that these points are
important enough that you should start a habit of adhering to them right from
the start. It&amp;rsquo;ll help you in the long run, trust me :)&lt;/p&gt;

&lt;h2 id=&#34;make-commit-messages-lengthy:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Make commit messages lengthy&lt;/h2&gt;

&lt;p&gt;This is a fairly general trend I see. The commit messages such people generally
write are just a few words long. Most of the beginners have started using &lt;code&gt;git&lt;/code&gt;
as version control system. In git, such people have gotten used to using &lt;code&gt;git
commit -m &amp;quot;your commit message here&amp;quot;&lt;/code&gt; command. If you use this command, I am
sure you won&amp;rsquo;t even feel like writing a commit message more than what fits in
one line :). Do you know that you can just type &lt;code&gt;git commit&lt;/code&gt; and it will open
up an editor (vim or nano) to write the commit message? Start using this way,
and stop using &lt;code&gt;-m&lt;/code&gt; flag directly on command line. It&amp;rsquo;ll help you and your
colleagues :).&lt;/p&gt;

&lt;p&gt;I generally prefer to write a short description in the first line of commit
message, then leave a blank line, and then write a paragraph after that to
explain in more detail if required. The first line is the most important. Try
to describe as much as possible concisely in this single line. But don&amp;rsquo;t ever
let this line go above 100 characters, preferably 80. See this commit message
as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Don&#39;t allow access to POST /v1/purchases API without authentication

It was revealed during testing that the above mentioned API is accessible
even when accessed without authentication. This is a security risk. This
commit fixes it. One &#39;if&#39; condition added to reject API call if the user is
not authenticated.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might feel that it&amp;rsquo;s a lot of effort to write such log git commit messages.
But you can realise it&amp;rsquo;ll not take more than 2 minutes to write this. Much less
than how much time you spent writing code corresponding to this commit :)&lt;/p&gt;

&lt;p&gt;Note that commit messages are important part of documentation, and are
extremely important for debugging later.&lt;/p&gt;

&lt;h2 id=&#34;do-only-one-thing-in-a-commit:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Do only one thing in a commit&lt;/h2&gt;

&lt;p&gt;If you are fixing three issues, make sure you create three different commits
for each one, and never one big commit to include three bug fixes. Even if each
of these bugfixes are just a couple of lines. If you are doing a feature work,
then it&amp;rsquo;s okay to put all the feature work in one single commit, but for a
bugfixes, create a separate commit for each one. As you can see, you should get
comfortable with the idea that a commit can be as short as one line and as
large as couple of hundred of lines.  Let go of the feeling that your brain has
about lines in a commit, that it feels right only when there are 50-100 lines
in a commit. :)&lt;/p&gt;

&lt;p&gt;If you are using git, take use of &lt;code&gt;git add -p&lt;/code&gt; to add specific chunks of code
in git, instead of adding a complete file into git like you&amp;rsquo;re used to, by
doing &lt;code&gt;git add file1.py&lt;/code&gt;. It&amp;rsquo;s a pretty powerful tool. Spend 15 mins to
understand it and you&amp;rsquo;ll go &amp;lsquo;why didn&amp;rsquo;t I know about this till now!&amp;rsquo;&lt;/p&gt;

&lt;p&gt;I am realizing I can actually write &amp;lsquo;Git beginner mistakes&amp;rsquo; as a separate blog
:). But anyway, continuing..&lt;/p&gt;

&lt;h2 id=&#34;spaces-after-comma-and-colon:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Spaces after comma and colon&lt;/h2&gt;

&lt;p&gt;Just make this a habit. It improves your code quality.&lt;/p&gt;

&lt;p&gt;Example 1 - bad:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def create_user(name=name,height=height,weight=weight):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2 - good:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def create_user(name=name, height=height, weight=weight):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3 - bad:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request_dict = {&#39;name&#39;:name,&#39;height&#39;:height}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 4 - good:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request_dict = {&#39;name&#39;: name, &#39;height&#39;: height}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;write-a-lot-of-comments-and-docstrings:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Write a lot of comments and docstrings&lt;/h2&gt;

&lt;p&gt;If something is not abvious from the code, you should write a comment about
it. Also, make a habit of writing docstrings to functions/methods, even if it
is just a single line. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def create_user(name, height=None, weight=None):
    &#39;&#39;&#39;Create a user entry in database. Returns database object created for user.&#39;&#39;&#39;
    # Logic to create entry into db and return db object
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;write-todos-literally-everywhere:cd4fddc7a50aaf88948c76b1bce26509&#34;&gt;Write TODOs literally everywhere&lt;/h2&gt;

&lt;p&gt;While writing code, you realize it can be improved, but you don&amp;rsquo;t want to
improve it right now as it is not that important thing at this moment. What
should you do? Just create a TODO! I find this a very good compromise for
smaller tasks, instead of creating an issue in an issue/bug tracker. TODOs can
be written for improving on docstrings (&lt;code&gt;TODO(rushiagr): add more description
here&lt;/code&gt;), a more optimised version of code (e.g. &lt;code&gt;TODO(rushiagr): can be
optimised by using list comprehensions instead of the &#39;for&#39; loop&lt;/code&gt;), or a
refactoring (&lt;code&gt;TODO(rushiagr): create a common method of this thrice-duplicated
code&lt;/code&gt;). The parenteses specify who wrote the TODO, which can be helpful if
somebody wants to fix the todo but doesn&amp;rsquo;t know who to contact for more
information. But you can leave this part out too.&lt;/p&gt;

&lt;p&gt;I use TODOs so much that I created a Vim abbreviation for it, so that as soon
as I type &lt;code&gt;#t&lt;/code&gt; followed by a space, it auto-completes it to &lt;code&gt;# TODO(rushiagr):
&lt;/code&gt;. If you&amp;rsquo;re using Vim, you can do by adding this line to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:abbreviate #t # TODO(rushiagr):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all folks! :) Do let me know what you feel about this blog by
commenting. Do you know something which you too encountered a lot which is not
present in this article?  Or you disagree with something I wrote?&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Git(hub) Cheat Sheet</title>
      <link>http://www.rushiagr.com/blog/2013/03/19/github-cheat-sheet/</link>
      <pubDate>Tue, 19 Mar 2013 00:00:00 &#43;0000</pubDate>
      <author>Rushi Agrawal</author>
      <guid>http://www.rushiagr.com/blog/2013/03/19/github-cheat-sheet/</guid>
      <description>

&lt;p&gt;I am posting my github cheat sheet here. I started writing it as soon as I started
learning Github and Git. So, some of the content here can appear quite naive.
I will try to keep this blog post as updated as I can, and if you find any
suggestion, please comment!&lt;/p&gt;

&lt;p&gt;This post is just for a reference of commands. This post will be a bad way to learn
how git works. A basic understanding of git is assumed.&lt;/p&gt;

&lt;p&gt;##Initial configuration
Configure user details only for the first time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;Rushi Agrawal&amp;quot;
git config --global user.email &amp;quot;rushi.agr@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check your git configuration&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Branches
List all branches in the local repo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List all branches including remote-tracking branches&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List all branches (including the ones at remote)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creating your own branch &lt;code&gt;my_branch&lt;/code&gt;, with content same as your current branch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch my_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Switch to the newly created branch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout my_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute the above two commands in one line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b my_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to pull a branch &lt;code&gt;only_remote&lt;/code&gt; which exists at github (at remote &lt;code&gt;rushiagr&lt;/code&gt; but not in local repo. (More about &lt;code&gt;git remote update&lt;/code&gt; later)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote update
git checkout -b only_remote rushiagr/only_remote
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remotes:04d9bb0940f5046aa10fc2c8ba66e73a&#34;&gt;Remotes&lt;/h2&gt;

&lt;p&gt;Create a new remote &lt;code&gt;rushiagr&lt;/code&gt; which will track &lt;code&gt;cinder&lt;/code&gt; repository by user &lt;code&gt;rushiagr&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote add rushiagr https://github.com/rushiagr/cinder.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this is your personal repo, you can append the username in the remote as shown. After that, every time you push to the origin,
github will not ask for your username but only password.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote add rushiagr https://rushiagr@github.com/rushiagr/cinder.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delete the remote &lt;code&gt;rushiagr&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote rm rushiagr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;List all the remotes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above command only shows the names of remotes. To also check the links to the remotes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this is very important command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will contact the git server, and will update the local repository with ALL the content at ALL those remotes. The interesting part is, nothing will actually change. That is, no more new branches (which got created at the server after you last pulled from the server) were created, and the existing branches are also not updated. BUT, all the content goes into the magic &lt;code&gt;.git&lt;/code&gt; directory. After you&amp;rsquo;ve run this command, when you create a branch only existing at remote, the local git repo will not contact the server but will fetch all the contents from within the repository.&lt;/p&gt;

&lt;p&gt;To take a new branch from remote, and create a new branch having contents of that remote branch. (You might need to run &amp;lsquo;git remote update&amp;rsquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b stable/folsom origin/stable/folsom
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;push:04d9bb0940f5046aa10fc2c8ba66e73a&#34;&gt;Push&lt;/h2&gt;

&lt;p&gt;Pushing this newly created branch to remote &lt;code&gt;rushiagr&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push rushiagr my_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to push the local branch &lt;code&gt;my_branch&lt;/code&gt; with a different name to
remote, say &lt;code&gt;my_remote_branch&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push rushiagr my_branch:my_remote_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create an association with the remote (only first time):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push -u origin my_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push --set-upstream origin my_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pull:04d9bb0940f5046aa10fc2c8ba66e73a&#34;&gt;Pull&lt;/h2&gt;

&lt;p&gt;Git pull is nothing more than a macro that does git fetch and git merge, in
that order. The common syntax to pull from branch &lt;code&gt;remote_branch&lt;/code&gt; located at remote &lt;code&gt;remote_name&lt;/code&gt; to the current active branch in the local repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git pull remote_name remote_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;oops-i-didn-t-intend-to-do-that:04d9bb0940f5046aa10fc2c8ba66e73a&#34;&gt;Oops! I didn&amp;rsquo;t intend to do that!&lt;/h2&gt;

&lt;p&gt;####To undo last commit.
This will just undo the commit, but will keep changes, so that you can modify the files and commit again&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --soft HEAD^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####To not keep the uncommitted changes.
This command will wipe off all the changes which are not committed. Very useful when you made some changes but dont want to commit it. All the more useful when you &lt;code&gt;pull&lt;/code&gt;ed something but everything became a mess (possibly due to a merge conflict, or pulling to/from a different branch!)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --hard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####To delete a branch &lt;code&gt;timepass_testing&lt;/code&gt; from github server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push rushiagr --delete timepass_testing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(NOT &lt;code&gt;git push rushiagr --delete rushiagr/timepass_testing&lt;/code&gt;)
####Change author of the last commit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit --amend --author=&amp;quot;Rushi Agrawal &amp;lt;rushi.agr@gmail.com&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You committed some changes, but then you realised you wanted to add this one line to the commit. In such a case
just add that one line, and run this command to have this last change incorporated into that previous commit. This command also gives you an option to
change the commit message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -a --amend
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;show-me-the-money:04d9bb0940f5046aa10fc2c8ba66e73a&#34;&gt;Show me the money&lt;/h2&gt;

&lt;p&gt;To see the patch of the last commit without undoing the last commit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see the changes introduced by any earlier commit with commit id &lt;code&gt;c5bb6d821e10ca8f114fa0b3b0149bc8b7257a92&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git show c5bb6d821e10ca8f114fa0b3b0149bc8b7257a92
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see the latest changes you made &amp;ndash; the changes which have not been staged to be committed&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git diff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can redirect the output from the above three commands to a file, to create corresponding patch file.&lt;/p&gt;

&lt;h2 id=&#34;patching-in-git:04d9bb0940f5046aa10fc2c8ba66e73a&#34;&gt;Patching in git&lt;/h2&gt;

&lt;p&gt;Check the status of patch. How many lines changed, etc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git apply --stat patchfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check if the patch can be applied.
If no output or no error, patch can be applied safely&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git apply --check patchfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apply patch with signing-off (better way)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git am --signoff &amp;lt; patchfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normal way of applying patch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git apply patchfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Miscellaneous&lt;/p&gt;

&lt;p&gt;To pull only specific files from another branch: (here, assuming that we have two branches, &amp;lsquo;test&amp;rsquo;, and &amp;lsquo;master&amp;rsquo;, and currently we are on &amp;lsquo;master&amp;rsquo; branch. If you want to pull ##only &amp;lsquo;testfile.py&amp;rsquo; file from &amp;lsquo;test&amp;rsquo; branch to &amp;lsquo;master&amp;rsquo; branch, do this:)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout test testfile.py1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your master changed while you were working on your topic_branch, and if you want to merge the master&amp;rsquo;s changes, and also get an option to squash the changes you made on topic_branch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout master
git pull origin master
git checkout topic_branch
git rebase -i master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://christoph.ruegg.name/blog/2010/5/5/git-howto-revert-a-commit-already-pushed-to-a-remote-reposit.html&#34;&gt;Undo last commit at the remote repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(you can use git revert, but don’t know how exactly it works)&lt;/p&gt;

&lt;p&gt;Clone a specific branch git repository from github&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone -b stable/essex https://github.com/openstack-dev/devstack.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://makandracards.com/makandra/527-squash-several-git-commits-into-a-single-commit&#34;&gt;Squash several commits into one single commit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Checkout a previous commit with SHA commit id cff2580ad7bc16934b72dd9be7463eb090b31d55 from the current branch to a new branch &amp;lsquo;neew&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout -b neew cff2580ad7bc16934b72dd9be7463eb090b31d55
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
  </channel>
</rss>